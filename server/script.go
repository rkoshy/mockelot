package server

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/dop251/goja"
	"mockelot/models"
)

// ScriptResponse represents the response generated by a script
type ScriptResponse struct {
	Status  int               `json:"status"`
	Headers map[string]string `json:"headers"`
	Body    string            `json:"body"`
	Delay   int               `json:"delay"`
}

// ScriptError represents an error that occurred during script execution
type ScriptError struct {
	Message string `json:"message"`
	Line    int    `json:"line,omitempty"`
	Column  int    `json:"column,omitempty"`
}

func (e *ScriptError) Error() string {
	if e.Line > 0 {
		return fmt.Sprintf("script error at line %d, column %d: %s", e.Line, e.Column, e.Message)
	}
	return fmt.Sprintf("script error: %s", e.Message)
}

// ProcessScript executes a JavaScript script with access to request context
// and returns the modified response
func ProcessScript(scriptBody string, reqContext *RequestContext, originalResponse *models.MethodResponse) (*ScriptResponse, error) {
	// Create a new JavaScript runtime
	vm := goja.New()

	// Set up timeout context (5 second limit)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Channel to receive result or error
	resultChan := make(chan *ScriptResponse, 1)
	errChan := make(chan error, 1)

	go func() {
		result, err := runScript(vm, scriptBody, reqContext, originalResponse)
		if err != nil {
			errChan <- err
		} else {
			resultChan <- result
		}
	}()

	// Wait for result or timeout
	select {
	case result := <-resultChan:
		return result, nil
	case err := <-errChan:
		return nil, err
	case <-ctx.Done():
		vm.Interrupt("script execution timeout")
		return nil, &ScriptError{Message: "script execution timeout (5s limit)"}
	}
}

func runScript(vm *goja.Runtime, scriptBody string, reqContext *RequestContext, originalResponse *models.MethodResponse) (*ScriptResponse, error) {
	// Prepare headers for response (convert from original or use empty map)
	originalHeaders := make(map[string]interface{})
	if originalResponse.Headers != nil {
		for k, v := range originalResponse.Headers {
			originalHeaders[k] = v
		}
	}

	// Initialize result object to be returned
	result := &ScriptResponse{
		Status:  originalResponse.StatusCode,
		Headers: make(map[string]string),
		Body:    originalResponse.Body,
		Delay:   originalResponse.ResponseDelay,
	}
	// Copy original headers to result
	if originalResponse.Headers != nil {
		for k, v := range originalResponse.Headers {
			result.Headers[k] = v
		}
	}

	// Set up request object (read-only)
	requestObj := reqContext.ToMap()
	if err := vm.Set("request", requestObj); err != nil {
		return nil, &ScriptError{Message: fmt.Sprintf("failed to set request object: %v", err)}
	}

	// Set up response object (writable) as plain JavaScript object for Goja compatibility
	responseObj := map[string]interface{}{
		"status":  originalResponse.StatusCode,
		"headers": originalHeaders,
		"body":    originalResponse.Body,
		"delay":   originalResponse.ResponseDelay,
	}
	if err := vm.Set("response", responseObj); err != nil {
		return nil, &ScriptError{Message: fmt.Sprintf("failed to set response object: %v", err)}
	}

	// Add console.log for debugging
	console := map[string]interface{}{
		"log": func(args ...interface{}) {
			// In production, you might want to collect these logs
			// For now, we'll just ignore them
		},
		"error": func(args ...interface{}) {
			// Same as log
		},
		"warn": func(args ...interface{}) {
			// Same as log
		},
	}
	if err := vm.Set("console", console); err != nil {
		return nil, &ScriptError{Message: fmt.Sprintf("failed to set console object: %v", err)}
	}

	// Add JSON utility (overrides native, but with proper Go interop)
	jsonUtil := map[string]interface{}{
		"stringify": func(v interface{}, args ...interface{}) string {
			var indent string
			if len(args) >= 2 {
				if spaces, ok := args[1].(int64); ok {
					for i := int64(0); i < spaces; i++ {
						indent += " "
					}
				}
			}
			var b []byte
			var err error
			if indent != "" {
				b, err = json.MarshalIndent(v, "", indent)
			} else {
				b, err = json.Marshal(v)
			}
			if err != nil {
				return ""
			}
			return string(b)
		},
		"parse": func(s string) interface{} {
			var v interface{}
			if err := json.Unmarshal([]byte(s), &v); err != nil {
				return nil
			}
			return v
		},
	}
	if err := vm.Set("JSON", jsonUtil); err != nil {
		return nil, &ScriptError{Message: fmt.Sprintf("failed to set JSON object: %v", err)}
	}

	// Execute the script
	_, err := vm.RunString(scriptBody)
	if err != nil {
		if jsErr, ok := err.(*goja.Exception); ok {
			return nil, &ScriptError{Message: jsErr.String()}
		}
		return nil, &ScriptError{Message: err.Error()}
	}

	// Extract updated response from VM
	responseVal := vm.Get("response")
	if responseVal != nil && !goja.IsUndefined(responseVal) && !goja.IsNull(responseVal) {
		responseExported := responseVal.Export()
		if respMap, ok := responseExported.(map[string]interface{}); ok {
			// Extract status
			if status, ok := respMap["status"].(int64); ok {
				result.Status = int(status)
			} else if status, ok := respMap["status"].(float64); ok {
				result.Status = int(status)
			}

			// Extract headers
			if headers, ok := respMap["headers"].(map[string]interface{}); ok {
				result.Headers = make(map[string]string)
				for k, v := range headers {
					if str, ok := v.(string); ok {
						result.Headers[k] = str
					} else {
						result.Headers[k] = fmt.Sprintf("%v", v)
					}
				}
			}

			// Extract body
			if body, ok := respMap["body"].(string); ok {
				result.Body = body
			}

			// Extract delay
			if delay, ok := respMap["delay"].(int64); ok {
				result.Delay = int(delay)
			} else if delay, ok := respMap["delay"].(float64); ok {
				result.Delay = int(delay)
			}
		}
	}

	return result, nil
}
